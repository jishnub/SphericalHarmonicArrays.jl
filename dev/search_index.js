var documenterSearchIndex = {"docs":
[{"location":"","page":"Reference","title":"Reference","text":"CurrentModule = SphericalHarmonicArrays","category":"page"},{"location":"#SphericalHarmonicArrays.jl","page":"Reference","title":"SphericalHarmonicArrays.jl","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"Modules = [SphericalHarmonicArrays]","category":"page"},{"location":"#SphericalHarmonicArrays.SHArray","page":"Reference","title":"SphericalHarmonicArrays.SHArray","text":"s = SHArray(arr::AbstractArray{T,N}, modes::NTuple{N, Union{AbstractUnitRange, SphericalHarmonicModes.ModeRange}}) where {T,N}\n\nCreate a wrapper around an array such that certain dimensions may be indexed using Tuple of spherical harmonic modes. Often the indices would be spherical harmonic degrees (l,m). The argument modes dictates the map between spherical harmonic modes and the indices of the parent array. The indices of modes that are of a ModeRange type correspond to the dimensions of s that enable indexing with a Tuple of spherical harmonic degrees.\n\nUse the iterators provided by SphericalHarmonicModes in modes to generate the map between the indices of the array and Tuples of spherical harmonic degrees. The resulting map would be of the form s[collect(modes[1])[i], collect(modes[2])[j], ...] == s[i,j, ...].\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> s = SHArray(reshape(1:4, 2, 2), (LM(0:1, 0:0), 1:2))\n2×2 SHArray(reshape(::UnitRange{Int64}, 2, 2), (LM(0:1, 0:0), 1:2)):\n 1  3\n 2  4\n\njulia> s.modes[1] |> collect\n2-element Vector{Tuple{Int64, Int64}}:\n (0, 0)\n (1, 0)\n\njulia> s[(1,0), 1]\n2\n\nSee also: SHVector, SHMatrix\n\n\n\n\n\n","category":"type"},{"location":"#SphericalHarmonicArrays.SHArray-Union{Tuple{N}, Tuple{AbstractArray{var\"#s5\", N} where var\"#s5\", Vararg{Pair{Int64, var\"#s6\"} where var\"#s6\"<:SphericalHarmonicModes.ModeRange, N} where N}} where N","page":"Reference","title":"SphericalHarmonicArrays.SHArray","text":"s = SHArray(arr::AbstractArray{T,N}, dimsmodes::Pairs{Int, <:SphericalHarmonicModes.ModeRange}) where {T,N}\n\nReturn an SHArray where the dimensions specified as the keys of dimsmodes may be indexed using Tuples of spherical harmonic degrees. This constructor is not type-stable in general, therefore this should be avoided within a loop if performance is a concern.\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> s2 = SHArray(reshape(1:4, 2, 2), 1 => LM(0:1, 0:0))\n2×2 SHArray(reshape(::UnitRange{Int64}, 2, 2), (LM(0:1, 0:0), Base.OneTo(2))):\n 1  3\n 2  4\n\n\n\n\n\n","category":"method"},{"location":"#SphericalHarmonicArrays.SHArray-Union{Tuple{N}, Tuple{T}, Tuple{Union{Missing, Nothing, UndefInitializer}, Tuple{Vararg{Union{Integer, SphericalHarmonicModes.ModeRange, AbstractUnitRange}, N}}}} where {T, N}","page":"Reference","title":"SphericalHarmonicArrays.SHArray","text":"SHArray{T}(init, modes::NTuple{N,Union{Integer, AbstractUnitRange, SphericalHarmonicModes.ModeRange}}) where {T,N}\n\nReturn an SHArray wrapper around a parent array of the appropriate size with N dimensions and elements of type T, such that the indices of modes that are of a ModeRange type may be indexed using Tuples of spherical harmonic degrees. The elements of the parent array are set according to the initializer init.\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> SHArray{Missing}(undef, (LM(0:1, 0:0), 2))\n2×2 SHArray(::Matrix{Missing}, (LM(0:1, 0:0), Base.OneTo(2))):\n missing  missing\n missing  missing\n\nSHArray{T}(modes::NTuple{N,Union{Integer, AbstractUnitRange, SphericalHarmonicModes.ModeRange}}) where {T,N}\n\nReturn an SHArray of the appropriate size with N dimensions and elements of type T. The elements are set to zero.\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> SHArray{Float64}((LM(1:1, 0:1), LM(0:0, 0:0)))\n2×1 SHArray(::Matrix{Float64}, (LM(1:1, 0:1), LM(0:0, 0:0))):\n 0.0\n 0.0\n\njulia> SHArray{Float64}((LM(1:1, 0:1), 2))\n2×2 SHArray(::Matrix{Float64}, (LM(1:1, 0:1), Base.OneTo(2))):\n 0.0  0.0\n 0.0  0.0\n\n\n\n\n\n","category":"method"},{"location":"#SphericalHarmonicArrays.SHMatrix","page":"Reference","title":"SphericalHarmonicArrays.SHMatrix","text":"SHMatrix(arr::AbstractMatrix, modes::NTuple{2,SphericalHarmonicModes.ModeRange})\nSHMatrix(arr::AbstractMatrix, modes::Vararg{SphericalHarmonicModes.ModeRange,2})\n\nReturn a wrapper that maps the indices of the parent matrix along each axis to a Tuple of spherical harmonic degrees. Often these Tuples would be pairs of spherical harmonic degrees (l,m).\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> s = SHMatrix(reshape(1:4, 2,2), (LM(0:1, 0:0), LM(1:2,0:0)))\n2×2 SHArray(reshape(::UnitRange{Int64}, 2, 2), (LM(0:1, 0:0), LM(1:2, 0:0))):\n 1  3\n 2  4\n\njulia> s[(1,0),(2,0)]\n4\n\nSee also: SHVector, SHArray\n\n\n\n\n\n","category":"type"},{"location":"#SphericalHarmonicArrays.SHMatrix-Union{Tuple{T}, Tuple{Union{Missing, Nothing, UndefInitializer}, Tuple{SphericalHarmonicModes.ModeRange, SphericalHarmonicModes.ModeRange}}} where T","page":"Reference","title":"SphericalHarmonicArrays.SHMatrix","text":"SHMatrix{T}(init, modes::NTuple{2,SphericalHarmonicModes.ModeRange}) where {T}\nSHMatrix{T}(init, modes::Vararg{SphericalHarmonicModes.ModeRange, 2}) where {T}\n\nReturn a SHMatrix wrapper, with the parent Matrix having elements of type T. The default value is set by the initializer init.\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> SHMatrix{Missing}(undef, LM(1:1), LM(0:1, 0:0))\n3×2 SHArray(::Matrix{Missing}, (LM(1:1, -1:1), LM(0:1, 0:0))):\n missing  missing\n missing  missing\n missing  missing\n\nSHMatrix{T}(modes::Vararg{SphericalHarmonicModes.ModeRange,2}) where {T}\nSHMatrix{T}(modes::NTuple{2,SphericalHarmonicModes.ModeRange}) where {T}\n\nReturn an SHMatrix of the appropriate size and with elements of type T. The elements are set to zero.\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> SHMatrix{ComplexF64}(LM(0:0, 0:0), LM(0:0, 0:0))\n1×1 SHArray(::Matrix{ComplexF64}, (LM(0:0, 0:0), LM(0:0, 0:0))):\n 0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"#SphericalHarmonicArrays.SHVector","page":"Reference","title":"SphericalHarmonicArrays.SHVector","text":"SHVector(arr::AbstractVector, modes::SphericalHarmonicModes.ModeRange)\n\nReturn a wrapper that maps the indices of the parent Vector to a Tuple of spherical harmonic degrees. Often the Tuple would be a pair of spherical harmonic degrees (l,m).\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> s = SHVector(1:3, LM(1:1))\n3-element SHArray(::UnitRange{Int64}, (LM(1:1, -1:1),)):\n 1\n 2\n 3\n\njulia> s.modes[1] |> collect\n3-element Vector{Tuple{Int64, Int64}}:\n (1, -1)\n (1, 0)\n (1, 1)\n\njulia> s[(1,0)]\n2\n\nSee also: SHMatrix, SHArray\n\n\n\n\n\n","category":"type"},{"location":"#SphericalHarmonicArrays.SHVector-Union{Tuple{T}, Tuple{Union{Missing, Nothing, UndefInitializer}, Tuple{SphericalHarmonicModes.ModeRange}}} where T","page":"Reference","title":"SphericalHarmonicArrays.SHVector","text":"SHVector{T}(init, modes::SphericalHarmonicModes.ModeRange) where {T}\nSHVector{T}(init, modes::Tuple{SphericalHarmonicModes.ModeRange}) where {T}\n\nReturn a SHVector wrapper, with the parent Vector having an element type of T. The default value is set by the initializer init.\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> SHVector{Missing}(undef, LM(1:1, -1:1))\n3-element SHArray(::Vector{Missing}, (LM(1:1, -1:1),)):\n missing\n missing\n missing\n\nSHVector{T}(modes::SphericalHarmonicModes.ModeRange) where {T}\nSHVector{T}(modes::Tuple{SphericalHarmonicModes.ModeRange}) where {T}\n\nReturn an SHVector of the appropriate size and with elements of type T. The elements are set to zero.\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> SHVector{ComplexF64}(LM(0:0, 0:0))\n1-element SHArray(::Vector{ComplexF64}, (LM(0:0, 0:0),)):\n 0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"#SphericalHarmonicArrays.shdims-Union{Tuple{SHArray{var\"#s5\", N, AA, TM} where {var\"#s5\", AA<:AbstractArray{var\"#s5\", N}, TM<:Tuple{Vararg{SphericalHarmonicModes.ModeRange, N}}}}, Tuple{N}} where N","page":"Reference","title":"SphericalHarmonicArrays.shdims","text":"shdims(arr::SHArray)\n\nReturn the dimensions of arr that may be indexed using ModeRanges. This is type-stable even if arr.modes contains inhomogeneous types.\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> s = SHArray{Float64}((LM(1:1,0:1), LM(0:0)));\n\njulia> SphericalHarmonicArrays.shdims(s)\n(1, 2)\n\njulia> s = SHArray{Float64}((LM(1:1,0:1), 2));\n\njulia> SphericalHarmonicArrays.shdims(s)\n(1,)\n\nSee also: shmodes\n\n\n\n\n\n","category":"method"},{"location":"#SphericalHarmonicArrays.shmodes-Tuple{SHArray{T, N, AA, TM} where {T, N, AA<:AbstractArray{T, N}, TM<:Tuple{Vararg{SphericalHarmonicModes.ModeRange, N}}}}","page":"Reference","title":"SphericalHarmonicArrays.shmodes","text":"SphericalHarmonicArrays.shmodes(arr::SHArray)\n\nReturns a Tuple containing the elements of arr.modes that are of a SphericalHarmonicModes.ModeRange type. This is type-stable even if arr.modes contains inhomogeneous types.\n\nExamples\n\njulia> import SphericalHarmonicModes: LM\n\njulia> sa = SHArray{ComplexF64}((2,2));\n\njulia> SphericalHarmonicArrays.shmodes(sa)\n()\n\njulia> sa = SHArray{ComplexF64}((LM(1:1, 0:0),2));\n\njulia> SphericalHarmonicArrays.shmodes(sa)\n(LM(1:1, 0:0),)\n\njulia> sa = SHArray{ComplexF64}((LM(1:1, 0:0), LM(2:2)));\n\njulia> SphericalHarmonicArrays.shmodes(sa)\n(LM(1:1, 0:0), LM(2:2, -2:2))\n\nSee also: shdims\n\n\n\n\n\n","category":"method"}]
}
