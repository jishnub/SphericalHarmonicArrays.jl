var documenterSearchIndex = {"docs":
[{"location":"","page":"Reference","title":"Reference","text":"CurrentModule = SphericalHarmonicArrays","category":"page"},{"location":"#SphericalHarmonicArrays.jl","page":"Reference","title":"SphericalHarmonicArrays.jl","text":"","category":"section"},{"location":"","page":"Reference","title":"Reference","text":"Modules = [SphericalHarmonicArrays]","category":"page"},{"location":"#SphericalHarmonicArrays.SHArray","page":"Reference","title":"SphericalHarmonicArrays.SHArray","text":"SHArray(arr::AbstractArray{T,N}, modes::Tuple, shdims::NTuple{NSH, Int}) where {T,N,NSH}\n\nCreate a wrapper around an array such that the dimensions specified by shdims may be  indexed using a Tuple representing a collection of spherical harmonic degrees. Often this  would be a spherical harmonic mode represented by (l,m).\n\nUse the iterators provided by SphericalHarmonicModes in modes to generate the map between  the indices of the array and Tuples of spherical harmonic degrees.\n\nExamples\n\njulia> s = SHArray(reshape(1:4, 2, 2), (LM(0:1,0:0), 2))\n2×2 SHArray{Int64,2,Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}},Tuple{LM,Base.OneTo{Int64}},1}:\n 1  3\n 2  4\n\njulia> s.modes[1] |> collect\n2-element Array{Tuple{Int64,Int64},1}:\n (0, 0)\n (1, 0)\n\njulia> s[(1,0), 1]\n2\n\nSee also: SHVector, SHMatrix\n\n\n\n\n\n","category":"type"},{"location":"#SphericalHarmonicArrays.SHArray-Union{Tuple{T}, Tuple{Tuple{Vararg{Union{SphericalHarmonicModes.ModeRange, AbstractUnitRange},N} where N},Tuple{Vararg{Int64,N} where N}}} where T","page":"Reference","title":"SphericalHarmonicArrays.SHArray","text":"SHArray{T}(modes::Tuple, [shdims::Tuple])\n\nReturn an SHArray wrapper around a parent array of the appropriate size with elements of type T,  such that the dimensions specified by shdims may be indexed using Tuples of  spherical harmonic degrees. The elements of the parent array are set to zero by default.\n\nSHArray(modes::Tuple, [shdims::Tuple])\n\nReturn an SHArray of the appropriate size and element type ComplexF64.\n\nExamples\n\njulia> s = SHArray((LM(0:1,0:0), 2))\n2×2 SHArray{Complex{Float64},2,Array{Complex{Float64},2},Tuple{LM,Base.OneTo{Int64}},1}:\n 0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"method"},{"location":"#SphericalHarmonicArrays.SHMatrix-Tuple{AbstractArray{T,2} where T,Tuple{SphericalHarmonicModes.ModeRange,SphericalHarmonicModes.ModeRange}}","page":"Reference","title":"SphericalHarmonicArrays.SHMatrix","text":"SHMatrix(arr::AbstractMatrix, modes::NTuple{2,ModeRange})\nSHMatrix(arr::AbstractMatrix, ax1::ModeRange, ax2::ModeRange)\n\nReturn a wrapper that maps the indices of the parent matrix along each axis  to a Tuple of spherical harmonic degrees. Often these Tuples would be pairs of spherical harmonic modes (l,m).\n\nExamples\n\njulia> s = SHMatrix(reshape(1:4, 2,2), (LM(0:1, 0:0), LM(1:2,0:0)))\n2×2 SHArray{Int64,2,Base.ReshapedArray{Int64,2,UnitRange{Int64},Tuple{}},Tuple{LM,LM},2}:\n 1  3\n 2  4\n\njulia> s[(1,0),(2,0)]\n4\n\nSee also: SHVector, SHArray\n\n\n\n\n\n","category":"method"},{"location":"#SphericalHarmonicArrays.SHVector-Tuple{AbstractArray{T,1} where T,SphericalHarmonicModes.ModeRange}","page":"Reference","title":"SphericalHarmonicArrays.SHVector","text":"SHVector(arr::AbstractVector, mode::ModeRange)\n\nReturn a wrapper that maps the indices of the parent vector to a Tuple of spherical harmonic degrees. Often the Tuple would be a pair of spherical harmonic modes (l,m).\n\nExamples\n\njulia> s = SHVector(1:3, LM(1:1))\n3-element SHArray{Int64,1,UnitRange{Int64},Tuple{LM},1}:\n 1\n 2\n 3\n\njulia> s.modes[1] |> collect\n3-element Array{Tuple{Int64,Int64},1}:\n (1, -1)\n (1, 0)\n (1, 1)\n\njulia> s[(1,0)]\n2\n\nSee also: SHMatrix, SHArray\n\n\n\n\n\n","category":"method"}]
}
